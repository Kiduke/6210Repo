#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     SENSOR_GYRO,    sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorFL,       tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorFR,       tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorM,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorL1,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorL2,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorS,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";

//task dedicated to controlling the base and motion of the entire robot in respect to the arena
task base() {
	while(true) {
		getJoystickSettings(joystick);

		int leftControl = joystick.joy1_y1; //Control variables for responsiveness, ease of programming, and changeability
		int rightControl = joystick.joy1_y2;

		//Controls and scales left-side base wheels off of leftControl variable
		if (abs(leftControl) > 10) {
			motor[motorFL] = leftControl / 1.28; //Division by 1.28 is to scale joystick maximum of 128 down to motor maximum of 100
			motor[motorBL] = leftControl / 1.28;
		}
		else {
			motor[motorFL] = 0; //if leftControl is within deadzone, no power is carried to the motors
			motor[motorBL] = 0;
		}

		//Controls and scales right-side base wheels off of rightControl variable
		if (abs(rightControl) > 10) {
			motor[motorBR] = rightControl / 1.28; //Division by 1.28 is to scale joystick maximum of 128 down to motor maximum of 100
			motor[motorFR] = rightControl / 1.28;
		}
		else {
			motor[motorFR] = 0; //if rightControl is within deadzone, no power is carried to the motors
			motor[motorBR] = 0;
		}
		wait1Msec(5); //wait 5 miliseconds for latency
	}
}

//task dedicated to controlling the motion of the conveyer belts in front of the robot
task conveyer() {

	int conveyerDir = 0;

	int conveyerButtonIn = joy1Btn(1); //Control variables for responsiveness, ease of programming, and changeability
	int conveyerButtonOut = joy1Btn(2);


		//Conveyer Manual Block, interchange with Conveyer Toggle Block, never both
/*	if (conveyerButtonIn == 1) { //Run Conveyer in positive direction, towards the robot
		motor[motorM] = 127;
	}
	else if (conveyerButtonOut == 1) { //Run Conveyer in negative direction, away from the robot
		motor[motorM] = -127;
	}
	else {
		motor[motorM] = 0;
	}*/


	/*
	#Conveyer Toggle Block, interchange with Conveyer Manual Block, never both
	*/

	//changes conveyer motion to rotate inward if it is not already doing so
	//if conveyer is already moving inward, stop conveyer motion
	if (conveyerButtonIn == 1) {
		if (conveyerDir != 1) {
			conveyerDir = 1;
		}
		else {
			conveyerDir = 0;
		}
	}

	//changes conveyer motion to rotate outward if it is not already doing so
	//if conveyer is already moving outward, stop conveyer motion
	if (conveyerButtonOut == 1) {
			if (conveyerDir != -1) {
			conveyerDir = -1;
		}
		else {
			conveyerDir = 0;
		}
	}

	motor[motorM] = 93 * conveyerDir; //sets and scales conveyer motor power to conveyerDir variable
}



task manipulator() {
	getJoystickSettings(joystick);
	bool spring = false;
	bool toggleControl = false;

	int springToggle = joy1Btn(3);//Control variables for responsiveness, ease of programming, and changeabil
	int liftUp = joy1Btn(6);
	int liftDown = joy1Btn(7);


	//Spring Toggle Block
	if (springToggle == 1) {
		if (!toggleControl) {
			toggleControl = true;
			if (spring) {
				spring = false;
			}
			else {
				spring = true;
			}
		}
	}
	if (springToggle == 1) {
		toggleControl = false;
	}

	if (liftUp == 1 || liftDown == 1) { //lift control
		if (liftUp == 1 && liftDown == 1) {
			motor[motorL1] = 0;
			motor[motorL2] = 0;
		}
		else if (liftUp == 1) { //lift rises if the liftUp button is pressed
			motor[motorL1] = 85;
			motor[motorL2] = -85;
		}
		else if (liftDown == 1) { //lift lowers if the liftDown button is pressed
			motor[motorL1] = -85;
			motor[motorL2] = 85;
		}
	}
	wait1Msec(5);
}

task main() {
	waitForStart();
	startTask(base);
	startTask(manipulator);
	startTask(conveyer);
	while(true) {
		wait1Msec(5);
	}
}
